#pragma once
// (c) Robert Muth - see LICENSE for more info
// NOTE: this file is PARTIALLY autogenerated via: ./opcode_tab.py gen_h

#include "BE/Elf/enum_gen.h"  // for reloc types

#include <cstdint>
#include <string_view>

namespace cwerg::a32 {
using namespace cwerg;

/* @AUTOGEN-START@ */
constexpr const unsigned MAX_OPERANDS = 6;
constexpr const unsigned MAX_BIT_RANGES = 2;

enum class FK : uint8_t {
    NONE = 0,
    LIST = 1,
    INT = 2,
    INT_HEX = 3,
    INT_SIGNED = 4,
    INT_SIGNED_CUSTOM = 5,
    FLT_CUSTOM = 6,
};

enum class OK : uint8_t {
    Invalid = 0,
    REG_0_3 = 1,
    REG_8_11 = 2,
    REG_12_15 = 3,
    REG_16_19 = 4,
    REG_PAIR_12_15 = 5,
    DREG_0_3_5 = 6,
    DREG_12_15_22 = 7,
    DREG_16_19_7 = 8,
    SREG_0_3_5 = 9,
    SREG_12_15_22 = 10,
    SREG_16_19_7 = 11,
    SHIFT_MODE_5_6 = 12,
    REGLIST_0_15 = 13,
    REG_RANGE_0_7 = 14,
    REG_RANGE_1_7 = 15,
    PRED_28_31 = 16,
    IMM_0_7_TIMES_4 = 17,
    IMM_0_11 = 18,
    IMM_0_3_8_11 = 19,
    IMM_7_11 = 20,
    IMM_10_11_TIMES_8 = 21,
    IMM_0_23 = 22,
    IMM_0_7_8_11 = 23,
    IMM_FLT_ZERO = 24,
    IMM_0_11_16_19 = 25,
    SIMM_0_23 = 26,
};

enum class SR_UPDATE : uint8_t {
    NONE = 0,
    NZ = 1,
    NCZ_PSR = 2,
    NCZ = 4,
    NCZV = 5,
};

enum class MEM_WIDTH : uint8_t {
    NA = 0,
    W1 = 1,
    W2 = 2,
    W4 = 3,
    W8 = 4,
    W12 = 5,
    Variable = 6,
};

enum OPC_FLAG {
    RESULT_64BIT = 1,
    SRC_DST_0_1 = 2,
    DST_0_1 = 4,
    DIV = 8,
    MUL = 16,
    MULACC = 32,
    LOAD = 64,
    STORE = 128,
    ATOMIC = 0x100,
    ALU = 0x200,
    ALU1 = 0x400,
    SIGNEXTEND = 0x800,
    JUMP = 0x1000,
    LINK = 0x2000,
    THUMB = 0x4000,
    MOVETOSR = 0x8000,
    MOVEFROMSR = 0x10000,
    TEST = 0x20000,
    PREFETCH = 0x40000,
    MULTIPLE = 0x80000,
    VFP = 0x100000,
    SYSCALL = 0x200000,
    BYTEREORDER = 0x400000,
    MISC = 0x800000,
    ADDR_PRE = 0x1000000,
    ADDR_POST = 0x2000000,
    ADDR_INC = 0x4000000,
    ADDR_DEC = 0x8000000,
    ADDR_UPDATE = 0x10000000,
};

enum class PRED : uint8_t {
    eq = 0,
    ne = 1,
    cs = 2,
    cc = 3,
    mi = 4,
    pl = 5,
    vs = 6,
    vc = 7,
    hi = 8,
    ls = 9,
    ge = 10,
    lt = 11,
    gt = 12,
    le = 13,
    al = 14,
    invalid_pred = 15,
};

enum class REG : uint8_t {
    r0 = 0,
    r1 = 1,
    r2 = 2,
    r3 = 3,
    r4 = 4,
    r5 = 5,
    r6 = 6,
    r7 = 7,
    r8 = 8,
    r9 = 9,
    sl = 10,
    fp = 11,
    ip = 12,
    sp = 13,
    lr = 14,
    pc = 15,
};

enum class SREG : uint8_t {
    s0 = 0,
    s1 = 1,
    s2 = 2,
    s3 = 3,
    s4 = 4,
    s5 = 5,
    s6 = 6,
    s7 = 7,
    s8 = 8,
    s9 = 9,
    s10 = 10,
    s11 = 11,
    s12 = 12,
    s13 = 13,
    s14 = 14,
    s15 = 15,
    s16 = 16,
    s17 = 17,
    s18 = 18,
    s19 = 19,
    s20 = 20,
    s21 = 21,
    s22 = 22,
    s23 = 23,
    s24 = 24,
    s25 = 25,
    s26 = 26,
    s27 = 27,
    s28 = 28,
    s29 = 29,
    s30 = 30,
    s31 = 31,
};

enum class DREG : uint8_t {
    d0 = 0,
    d1 = 1,
    d2 = 2,
    d3 = 3,
    d4 = 4,
    d5 = 5,
    d6 = 6,
    d7 = 7,
    d8 = 8,
    d9 = 9,
    d10 = 10,
    d11 = 11,
    d12 = 12,
    d13 = 13,
    d14 = 14,
    d15 = 15,
};

enum class SHIFT : uint8_t {
    lsl = 0,
    lsr = 1,
    asr = 2,
    ror = 3,
};

enum class OPC : uint16_t {
    invalid,
    adc_imm,
    adc_regimm,
    adc_regreg,
    adcs_imm,
    adcs_regimm,
    adcs_regreg,
    add_imm,
    add_regimm,
    add_regreg,
    adds_imm,
    adds_regimm,
    adds_regreg,
    and_imm,
    and_regimm,
    and_regreg,
    ands_imm,
    ands_regimm,
    ands_regreg,
    b,
    bic_imm,
    bic_regimm,
    bic_regreg,
    bics_imm,
    bics_regimm,
    bics_regreg,
    bl,
    blx_reg,
    bx,
    clz,
    cmn_imm,
    cmn_regimm,
    cmn_regreg,
    cmp_imm,
    cmp_regimm,
    cmp_regreg,
    eor_imm,
    eor_regimm,
    eor_regreg,
    eors_imm,
    eors_regimm,
    eors_regreg,
    ldmda,
    ldmda_update,
    ldmdb,
    ldmdb_update,
    ldmia,
    ldmia_update,
    ldmib,
    ldmib_update,
    ldp_imm_add,
    ldp_imm_add_post,
    ldp_imm_add_pre,
    ldp_imm_sub,
    ldp_imm_sub_post,
    ldp_imm_sub_pre,
    ldp_reg_add,
    ldp_reg_add_post,
    ldp_reg_add_pre,
    ldp_reg_sub,
    ldp_reg_sub_post,
    ldp_reg_sub_pre,
    ldr_imm_add,
    ldr_imm_add_post,
    ldr_imm_add_pre,
    ldr_imm_sub,
    ldr_imm_sub_post,
    ldr_imm_sub_pre,
    ldr_reg_add,
    ldr_reg_add_post,
    ldr_reg_add_pre,
    ldr_reg_sub,
    ldr_reg_sub_post,
    ldr_reg_sub_pre,
    ldrb_imm_add,
    ldrb_imm_add_post,
    ldrb_imm_add_pre,
    ldrb_imm_sub,
    ldrb_imm_sub_post,
    ldrb_imm_sub_pre,
    ldrb_reg_add,
    ldrb_reg_add_post,
    ldrb_reg_add_pre,
    ldrb_reg_sub,
    ldrb_reg_sub_post,
    ldrb_reg_sub_pre,
    ldrd_imm_add,
    ldrd_imm_add_post,
    ldrd_imm_add_pre,
    ldrd_imm_sub,
    ldrd_imm_sub_post,
    ldrd_imm_sub_pre,
    ldrd_reg_add,
    ldrd_reg_add_post,
    ldrd_reg_add_pre,
    ldrd_reg_sub,
    ldrd_reg_sub_post,
    ldrd_reg_sub_pre,
    ldrex,
    ldrexb,
    ldrexh,
    ldrh_imm_add,
    ldrh_imm_add_post,
    ldrh_imm_add_pre,
    ldrh_imm_sub,
    ldrh_imm_sub_post,
    ldrh_imm_sub_pre,
    ldrh_reg_add,
    ldrh_reg_add_post,
    ldrh_reg_add_pre,
    ldrh_reg_sub,
    ldrh_reg_sub_post,
    ldrh_reg_sub_pre,
    ldrsb_imm_add,
    ldrsb_imm_add_post,
    ldrsb_imm_add_pre,
    ldrsb_imm_sub,
    ldrsb_imm_sub_post,
    ldrsb_imm_sub_pre,
    ldrsb_reg_add,
    ldrsb_reg_add_post,
    ldrsb_reg_add_pre,
    ldrsb_reg_sub,
    ldrsb_reg_sub_post,
    ldrsb_reg_sub_pre,
    ldrsh_imm_add,
    ldrsh_imm_add_post,
    ldrsh_imm_add_pre,
    ldrsh_imm_sub,
    ldrsh_imm_sub_post,
    ldrsh_imm_sub_pre,
    ldrsh_reg_add,
    ldrsh_reg_add_post,
    ldrsh_reg_add_pre,
    ldrsh_reg_sub,
    ldrsh_reg_sub_post,
    ldrsh_reg_sub_pre,
    mla,
    mlas,
    mls,
    mov_imm,
    mov_regimm,
    mov_regreg,
    movs_imm,
    movs_regimm,
    movs_regreg,
    movt,
    movw,
    mul,
    muls,
    mvn_imm,
    mvn_regimm,
    mvn_regreg,
    mvns_imm,
    mvns_regimm,
    mvns_regreg,
    orr_imm,
    orr_regimm,
    orr_regreg,
    orrs_imm,
    orrs_regimm,
    orrs_regreg,
    rbit,
    rev,
    rev16,
    rsb_imm,
    rsb_regimm,
    rsb_regreg,
    rsbs_imm,
    rsbs_regimm,
    rsbs_regreg,
    rsc_imm,
    rsc_regimm,
    rsc_regreg,
    rscs_imm,
    rscs_regimm,
    rscs_regreg,
    sbc_imm,
    sbc_regimm,
    sbc_regreg,
    sbcs_imm,
    sbcs_regimm,
    sbcs_regreg,
    sdiv,
    smlabb,
    smlabt,
    smlal,
    smlals,
    smlatb,
    smlatt,
    smulbb,
    smulbt,
    smull,
    smulls,
    smultb,
    smultt,
    stmda,
    stmda_update,
    stmdb,
    stmdb_update,
    stmia,
    stmia_update,
    stmib,
    stmib_update,
    str_imm_add,
    str_imm_add_post,
    str_imm_add_pre,
    str_imm_sub,
    str_imm_sub_post,
    str_imm_sub_pre,
    str_reg_add,
    str_reg_add_post,
    str_reg_add_pre,
    str_reg_sub,
    str_reg_sub_post,
    str_reg_sub_pre,
    strb_imm_add,
    strb_imm_add_post,
    strb_imm_add_pre,
    strb_imm_sub,
    strb_imm_sub_post,
    strb_imm_sub_pre,
    strb_reg_add,
    strb_reg_add_post,
    strb_reg_add_pre,
    strb_reg_sub,
    strb_reg_sub_post,
    strb_reg_sub_pre,
    strd_imm_add,
    strd_imm_add_post,
    strd_imm_add_pre,
    strd_imm_sub,
    strd_imm_sub_post,
    strd_imm_sub_pre,
    strd_reg_add,
    strd_reg_add_post,
    strd_reg_add_pre,
    strd_reg_sub,
    strd_reg_sub_post,
    strd_reg_sub_pre,
    strex,
    strexb,
    strexh,
    strh_imm_add,
    strh_imm_add_post,
    strh_imm_add_pre,
    strh_imm_sub,
    strh_imm_sub_post,
    strh_imm_sub_pre,
    strh_reg_add,
    strh_reg_add_post,
    strh_reg_add_pre,
    strh_reg_sub,
    strh_reg_sub_post,
    strh_reg_sub_pre,
    sub_imm,
    sub_regimm,
    sub_regreg,
    subs_imm,
    subs_regimm,
    subs_regreg,
    svc,
    swp,
    swpb,
    sxtab,
    sxtab16,
    sxtah,
    sxtb,
    sxtb16,
    sxth,
    teq_imm,
    teq_regimm,
    teq_regreg,
    tst_imm,
    tst_regimm,
    tst_regreg,
    ud2,
    udiv,
    umlal,
    umlals,
    umull,
    umulls,
    uxtab,
    uxtab16,
    uxtah,
    uxtb,
    uxtb16,
    uxth,
    vabs_f32,
    vabs_f64,
    vadd_f32,
    vadd_f64,
    vcmp_f32,
    vcmp_f32_zero,
    vcmp_f64,
    vcmp_f64_zero,
    vcmpe_f32,
    vcmpe_f32_zero,
    vcmpe_f64,
    vcmpe_f64_zero,
    vcvt_f32_f64,
    vcvt_f32_s32,
    vcvt_f32_u32,
    vcvt_f64_f32,
    vcvt_f64_s32,
    vcvt_f64_u32,
    vcvt_s32_f32,
    vcvt_s32_f64,
    vcvt_u32_f32,
    vcvt_u32_f64,
    vdiv_f32,
    vdiv_f64,
    vldmda_f,
    vldmda_f_update,
    vldmda_s,
    vldmda_s_update,
    vldmdb_f,
    vldmdb_f_update,
    vldmdb_s,
    vldmdb_s_update,
    vldmia_f,
    vldmia_f_update,
    vldmia_s,
    vldmia_s_update,
    vldmib_f,
    vldmib_f_update,
    vldmib_s,
    vldmib_s_update,
    vldr_f32_add,
    vldr_f32_sub,
    vldr_f64_add,
    vldr_f64_sub,
    vmla_f32,
    vmla_f64,
    vmls_f32,
    vmls_f64,
    vmov_atof,
    vmov_atos,
    vmov_f32,
    vmov_f64,
    vmov_ftoa,
    vmov_stoa,
    vmrs_APSR_nzcv_fpscr,
    vmul_f32,
    vmul_f64,
    vneg_f32,
    vneg_f64,
    vnmla_f32,
    vnmla_f64,
    vnmls_f32,
    vnmls_f64,
    vnmul_f32,
    vnmul_f64,
    vsqrt_f32,
    vsqrt_f64,
    vstmda_f,
    vstmda_f_update,
    vstmda_s,
    vstmda_s_update,
    vstmdb_f,
    vstmdb_f_update,
    vstmdb_s,
    vstmdb_s_update,
    vstmia_f,
    vstmia_f_update,
    vstmia_s,
    vstmia_s_update,
    vstmib_f,
    vstmib_f_update,
    vstmib_s,
    vstmib_s_update,
    vstr_f32_add,
    vstr_f32_sub,
    vstr_f64_add,
    vstr_f64_sub,
    vsub_f32,
    vsub_f64,
};
/* @AUTOGEN-END@ */

// Describes a class of instructions structurally (read-only data).
struct Opcode {
  const char* name;
  const char* enum_name;
  uint32_t bit_mask;
  uint32_t bit_value;
  uint8_t num_fields;
  OK fields[MAX_OPERANDS];
  uint32_t classes;
  MEM_WIDTH mem_width;
  SR_UPDATE sr_update;
};

// Indexed by OPC
extern const Opcode OpcodeTable[];

// Find the Opcode or null for a 32 bit instruction word
extern const Opcode* FindOpcode(uint32_t bit_value);

extern const Opcode* FindOpcodeForMnemonic(std::string_view s);


// Decoded representation of the instruction word
struct Ins {
  const Opcode* opcode;
  // Number of used entries is ArmOpcode.num_fields.
  // None of the values can be  kEncodeFailure since the widest operand
  // is 24 bits.
  uint32_t operands[MAX_OPERANDS];
  // Relocation info
  std::string_view reloc_symbol;
  elf::RELOC_TYPE_ARM reloc_kind = elf::RELOC_TYPE_ARM::NONE;
  uint8_t reloc_pos;  // index into  operands
  bool is_local_sym = false;
  bool has_reloc() const { return reloc_kind != elf::RELOC_TYPE_ARM::NONE; }

  void clear_reloc() {
    if (has_reloc()) {
      reloc_kind = elf::RELOC_TYPE_ARM::NONE;
      operands[reloc_pos] = 0;
    }
  }
  void set_reloc(elf::RELOC_TYPE_ARM kind,
                 bool is_local,
                 uint8_t pos,
                 std::string_view symbol) {
    reloc_kind = kind;
    is_local_sym = is_local;
    reloc_pos = pos;
    reloc_symbol = symbol;
  }
};


// Decode the instruction word `data`
// Returns true if successful
extern bool Disassemble(Ins* ins, uint32_t data);

// Encode the instruction
// Returns the instruction word. Asserts if unsuccessful
extern uint32_t Assemble(const Ins& ins);

extern uint32_t Patch(uint32_t data, unsigned pos, int32_t value);

struct BitRange {
  uint8_t width;  // if this is zero , the bitrange is invalid
  uint8_t position;
};


typedef uint32_t (*ENC_DEC_FUN)(uint32_t);

struct FieldInfo {
  BitRange ranges[MAX_BIT_RANGES];
  const char* const* names;  // points  PRED_ToStringMap, SHIFT_ToStringMap etc
  std::string_view prefix;
  ENC_DEC_FUN decoder;
  ENC_DEC_FUN encoder;
  uint8_t bitwidth;
  FK kind;
  uint8_t scale;
  uint8_t num_names;
};

// Indexed by OK
extern const FieldInfo FieldInfoTable[];

extern uint32_t  DecodeRotatedImm(uint32_t data);

const uint32_t kEncodeFailure = 0xffffffff;

// Tries to encode a 32 bit immediate value as a standard
// ARM 12bit shifted immediate.
// If this is successful a 12bit unsigned value is returned.
// Otherwise, kEncodingFailure is returned.
extern uint32_t EncodeRotatedImm(uint32_t immediate);

// Note, this returns the unsigned equivalent of the signed quantity
extern uint32_t SignedIntFromBits(uint32_t data, unsigned n_bits);


extern uint32_t EncodeOperand(uint32_t data, OK ok);
extern uint32_t DecodeOperand(uint32_t data, OK ok);

extern const char* EnumToString(REG x);
extern const char* EnumToString(DREG x);
extern const char* EnumToString(SREG x);
extern const char* EnumToString(PRED x);
extern const char* EnumToString(SHIFT x);
extern const char* EnumToString(OK x);


}  // namespace cwerg::a32

