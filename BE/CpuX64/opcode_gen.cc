// NOTE: this file is PARTIALLY autogenerated via: ./opcode_tab.py gen_c
#include "BE/CpuX64/opcode_gen.h"

#include <cstring>
#include <iostream>

#include "Util/assert.h"

namespace cwerg::x64 {

// +-prefix converts an enum the underlying type
template <typename T>
constexpr auto operator+(T e) noexcept
    -> std::enable_if_t<std::is_enum<T>::value, std::underlying_type_t<T>> {
  return static_cast<std::underlying_type_t<T>>(e);
}

#include "BE/CpuX64/opcode_gen_collisions.h"
#include "BE/CpuX64/opcode_gen_encodings.h"
#include "BE/CpuX64/opcode_gen_names.h"

/* @AUTOGEN-START@ */

const char* const OK_ToStringMap[] = {
    "", // 0
    "RIP_BASE", // 1
    "MODRM_RM_BASE", // 2
    "OFFABS8", // 3
    "OFFABS32", // 4
    "SIB_SCALE", // 5
    "SIB_INDEX", // 6
    "SIB_BASE", // 7
    "SIB_INDEX_AS_BASE", // 8
    "", // 9
    "IMM8", // 10
    "IMM16", // 11
    "IMM32", // 12
    "OFFPCREL8", // 13
    "OFFPCREL32", // 14
    "", // 15
    "", // 16
    "IMM8_16", // 17
    "IMM8_32", // 18
    "IMM8_64", // 19
    "IMM32_64", // 20
    "IMM64", // 21
    "", // 22
    "", // 23
    "BYTE_WITH_REG8", // 24
    "BYTE_WITH_REG16", // 25
    "BYTE_WITH_REG32", // 26
    "BYTE_WITH_REG64", // 27
    "MODRM_RM_REG8", // 28
    "MODRM_RM_REG16", // 29
    "MODRM_RM_REG32", // 30
    "MODRM_RM_REG64", // 31
    "MODRM_RM_XREG32", // 32
    "MODRM_RM_XREG64", // 33
    "MODRM_RM_XREG128", // 34
    "MODRM_REG8", // 35
    "MODRM_REG16", // 36
    "MODRM_REG32", // 37
    "MODRM_REG64", // 38
    "MODRM_XREG32", // 39
    "MODRM_XREG64", // 40
    "MODRM_XREG128", // 41
    "", // 42
    "", // 43
    "", // 44
    "", // 45
    "", // 46
    "", // 47
    "", // 48
    "", // 49
    "IMPLICIT_AL", // 50
    "IMPLICIT_AX", // 51
    "IMPLICIT_EAX", // 52
    "IMPLICIT_RAX", // 53
    "IMPLICIT_DX", // 54
    "IMPLICIT_EDX", // 55
    "IMPLICIT_RDX", // 56
    "IMPLICIT_CL", // 57
    "", // 58
    "", // 59
    "", // 60
    "", // 61
    "", // 62
    "", // 63
    "", // 64
    "", // 65
    "", // 66
    "", // 67
    "IMPLICIT_1", // 68
};
const char* EnumToString(OK x) { return OK_ToStringMap[unsigned(x)]; }

/* @AUTOGEN-END@ */
size_t GetRexPos(const Opcode& opcode, std::string_view data) {
  for (size_t i = 0; i < data.size(); ++i) {
    uint8_t d = data[i];
    if (d == 0x66 || d == 0xf0 || d == 0xf2 || d == 0xf3) continue;
    if ((d & 0xf0) == 0x40) return i;
    break;
  }
  return opcode.num_bytes;
}

uint64_t GetRegBits(std::string_view data, size_t rex_pos, uint32_t offset,
                    uint32_t data_bit_pos, uint32_t rex_bit_pos) {
  if (offset >= rex_pos) offset += 1;

  uint64_t r = (data[offset] >> data_bit_pos) & 0x7;
  if (rex_pos < offset) {
    r |= ((data[rex_pos] >> rex_bit_pos) & 1) << 3;
  }
  return r;
}

uint64_t GetSInt(std::string_view data, size_t rex_pos, int32_t pos,
                 uint32_t src_width, uint32_t dst_width) {
  if (pos >= rex_pos) pos++;
  int32_t end_pos = pos + src_width / 8 - 1;

  int64_t r = int64_t(data[end_pos--]);
  while (end_pos >= pos) {
    r = (r << 8) | uint8_t(data[end_pos--]);
  }

  if (dst_width == 0 || dst_width == 64) return r;
  return r & ((1ULL << dst_width) - 1);
}

uint64_t GetOperand(OK ok, const Opcode& opcode, std::string_view data,
                    size_t rex_pos) {
  switch (ok) {
    case OK::IMPLICIT_AL:
    case OK::IMPLICIT_AX:
    case OK::IMPLICIT_EAX:
    case OK::IMPLICIT_RAX:
    case OK::IMPLICIT_DX:
    case OK::IMPLICIT_EDX:
    case OK::IMPLICIT_RDX:
    case OK::IMPLICIT_CL:
    case OK::IMPLICIT_1:
      return 0;
    case OK::MODRM_RM_REG8:
    case OK::MODRM_RM_REG16:
    case OK::MODRM_RM_REG32:
    case OK::MODRM_RM_REG64: {
      uint64_t result = GetRegBits(data, rex_pos, opcode.modrm_pos, 0, 0);
      if (ok == OK::MODRM_RM_REG8 && 4 <= result && result <= 7) {
        ASSERT(rex_pos <= opcode.modrm_pos, "");
      }
      return result;
    }
    case OK::MODRM_RM_XREG32:
    case OK::MODRM_RM_XREG64:
    case OK::MODRM_RM_XREG128:
    case OK::MODRM_RM_BASE:
      return GetRegBits(data, rex_pos, opcode.modrm_pos, 0, 0);
    case OK::MODRM_REG8:
    case OK::MODRM_REG16:
    case OK::MODRM_REG32:
    case OK::MODRM_REG64: {
      uint64_t result = GetRegBits(data, rex_pos, opcode.modrm_pos, 3, 2);
      if (ok == OK::MODRM_REG8 && 4 <= result && result <= 7) {
        ASSERT(rex_pos <= opcode.modrm_pos, "");
      }
      return result;
    }
    case OK::MODRM_XREG32:
    case OK::MODRM_XREG64:
    case OK::MODRM_XREG128:
      return GetRegBits(data, rex_pos, opcode.modrm_pos, 3, 2);
    case OK::RIP_BASE:
      return 0;
    case OK::SIB_BASE:
      return GetRegBits(data, rex_pos, opcode.sib_pos, 0, 0);
    case OK::SIB_INDEX:
      return GetRegBits(data, rex_pos, opcode.sib_pos, 3, 1);
    case OK::SIB_INDEX_AS_BASE: {
      uint64_t result = GetRegBits(data, rex_pos, opcode.sib_pos, 3, 1);
      ASSERT(result != 4, "");
      return result;
    }
    case OK::SIB_SCALE:
      return (data[opcode.sib_pos + uint32_t(rex_pos <= opcode.sib_pos)] >> 6) &
             3;
    case OK::BYTE_WITH_REG8: {
      uint64_t result =
          GetRegBits(data, rex_pos, opcode.byte_with_reg_pos, 0, 0);
      ASSERT(4 <= result && result <= 7, "");
      return result;
    }
    case OK::BYTE_WITH_REG16:
    case OK::BYTE_WITH_REG32:
    case OK::BYTE_WITH_REG64:
      return GetRegBits(data, rex_pos, opcode.byte_with_reg_pos, 0, 0);
    case OK::IMM8:
      return GetSInt(data, rex_pos, opcode.imm_pos, 8, 8);
    case OK::IMM16:
      return GetSInt(data, rex_pos, opcode.imm_pos, 16, 16);
    case OK::IMM32:
      return GetSInt(data, rex_pos, opcode.imm_pos, 32, 32);
    case OK::IMM8_16:
      return GetSInt(data, rex_pos, opcode.imm_pos, 8, 16);
    case OK::IMM8_32:
      return GetSInt(data, rex_pos, opcode.imm_pos, 8, 32);
    case OK::IMM8_64:
      return GetSInt(data, rex_pos, opcode.imm_pos, 8, 64);
    case OK::IMM32_64:
      return GetSInt(data, rex_pos, opcode.imm_pos, 32, 64);
    case OK::IMM64:
      return GetSInt(data, rex_pos, opcode.imm_pos, 64, 64);
    case OK::OFFPCREL8:
    case OK::OFFABS8:
      return GetSInt(data, rex_pos, opcode.offset_pos, 8, 64);
    case OK::OFFPCREL32:
    case OK::OFFABS32:
      return GetSInt(data, rex_pos, opcode.offset_pos, 32, 64);
  }
  ASSERT(false, "Unsupported OK [" << unsigned(ok) << "]");
  return 0;
}

uint32_t _FP(bool bf0, bool b66, bool bf2, bool bf3, bool b0f, bool b48, uint8_t d) {
  return (bf0 << 13) | (b66 << 12) | (bf2 << 11) | (bf3 << 10) | (b0f << 9) | (b48 << 8) | d;
}

uint32_t FingerPrintRawInstructions(std::string_view data) {
  bool b48 = false;
  bool bf0 = false;
  bool bf2 = false;
  bool bf3 = false;
  bool b66 = false;
  for (size_t i = 0; i < data.size(); ++i) {
    uint8_t d = data[i];
    if ((d & 0xf0) == 0x40)
      b48 = (d >> 3) & 1;
    else if (d == 0x66)
      b66 = true;
    else if (d == 0xf0)
      bf0 = true;
    else if (d == 0xf2)
      bf2 = true;
    else if (d == 0xf3)
      bf3 = true;
    else if (d == 0x0f) {
      ASSERT(i + 1 < data.size(), "");
      return _FP(bf0, b66, bf2, bf3, 1, b48, data[i + 1]);
    } else
      return _FP(bf0, b66, bf2, bf3, 0, b48, d);
  }
  ASSERT(false, "unreachable");
  return 0;
}

bool OpcodeMatchesData(const Opcode& opcode, std::string_view data) {
  const size_t rex_pos = GetRexPos(opcode, data);

  if (data.size() < opcode.num_bytes + unsigned(rex_pos != opcode.num_bytes))
    return false;
  for (size_t i = 0, n = 0; i < opcode.num_bytes; ++i, ++n) {
    const uint8_t d = opcode.data[i];
    const uint8_t m = opcode.mask[i];
    if (n == rex_pos) ++n;
    const uint8_t x = data[n];
    if ((d & m) != (x & m)) return false;
  }

  return true;
}

const Opcode* FindOpcode(std::string_view data) {
  uint32_t index =
      FingerprintToCollisionIndex[FingerPrintRawInstructions(data)];
  while (true) {
    const OPC opc = FingerprintCollisions[index++];
    if (opc == OPC::invalid) return nullptr;
    const Opcode& opcode = OpcodeTableEncodings[+opc];
    if (OpcodeMatchesData(opcode, data)) return &opcode;
  }
  return nullptr;
}

bool Disassemble(Ins* ins, std::string_view data) {
  const Opcode* opcode = FindOpcode(data);
  if (opcode == nullptr) return false;
  ins->opcode = opcode;
  const size_t rex_pos = GetRexPos(*opcode, data);
  for (int i = 0; i < opcode->num_fields; ++i) {
    ins->operands[i] = GetOperand(opcode->fields[i], *opcode, data, rex_pos);
  }
  ins->clear_reloc();
  return true;
}

void SetRegBits(char* data, int64_t reg, uint32_t offset, uint32_t data_bit_pos,
                uint32_t rex_bit_pos, uint8_t* rex) {
  data[offset] |= (reg & 7) << data_bit_pos;
  *rex |= (reg >> 3) << rex_bit_pos;
}

void SetSInt(char* data, int64_t v, uint32_t pos, uint32_t width) {
  uint32_t end_pos = pos + width / 8;
  while (pos < end_pos) {
    data[pos++] = v & 0xff;
    v >>= 8;
  }
}

void SetOperand(OK ok, int64_t v, const Opcode& opcode, char* data,
                uint8_t* rex) {
  switch (ok) {
    case OK::IMPLICIT_AL:
    case OK::IMPLICIT_AX:
    case OK::IMPLICIT_EAX:
    case OK::IMPLICIT_RAX:
    case OK::IMPLICIT_DX:
    case OK::IMPLICIT_EDX:
    case OK::IMPLICIT_RDX:
    case OK::IMPLICIT_CL:
    case OK::IMPLICIT_1:
      return;  // do nothing
    case OK::MODRM_RM_REG8:
    case OK::MODRM_RM_REG16:
    case OK::MODRM_RM_REG32:
    case OK::MODRM_RM_REG64:
    case OK::MODRM_RM_XREG32:
    case OK::MODRM_RM_XREG64:
    case OK::MODRM_RM_XREG128:
    case OK::MODRM_RM_BASE:
      if (ok == OK::MODRM_RM_REG8 && 4 <= v && v <= 7) {
        *rex |= 0x40;
      }
      SetRegBits(data, v, opcode.modrm_pos, 0, 0, rex);
      return;
    case OK::MODRM_REG8:
    case OK::MODRM_REG16:
    case OK::MODRM_REG32:
    case OK::MODRM_REG64:
      if (ok == OK::MODRM_REG8 && 4 <= v && v <= 7) {
        *rex |= 0x40;
      }
      SetRegBits(data, v, opcode.modrm_pos, 3, 2, rex);
      return;
    case OK::MODRM_XREG32:
    case OK::MODRM_XREG64:
    case OK::MODRM_XREG128:
      SetRegBits(data, v, opcode.modrm_pos, 3, 2, rex);
      return;
    case OK::RIP_BASE:
      return;
    case OK::SIB_BASE:
      SetRegBits(data, v, opcode.sib_pos, 0, 0, rex);
      return;
    case OK::SIB_INDEX:
      SetRegBits(data, v, opcode.sib_pos, 3, 1, rex);
      return;
    case OK::SIB_INDEX_AS_BASE:
      SetRegBits(data, v, opcode.sib_pos, 3, 1, rex);
      ASSERT(v != 4, "");
      return;
    case OK::SIB_SCALE:
      ASSERT(0 <= v && v <= 3, "");
      data[opcode.sib_pos] |= v << 6;
      return;
    case OK::BYTE_WITH_REG8:
      SetRegBits(data, v, opcode.byte_with_reg_pos, 0, 0, rex);
      if (4 <= v && v <= 7) { // avoid high bytes 
          *rex |= 0x40;
      }
      return;
    case OK::BYTE_WITH_REG16:
    case OK::BYTE_WITH_REG32:
    case OK::BYTE_WITH_REG64:
      SetRegBits(data, v, opcode.byte_with_reg_pos, 0, 0, rex);
      return;
    case OK::IMM8:
    case OK::IMM8_16:
    case OK::IMM8_32:
    case OK::IMM8_64:
      SetSInt(data, v, opcode.imm_pos, 8);
      return;
    case OK::IMM16:
      SetSInt(data, v, opcode.imm_pos, 16);
      return;
    case OK::IMM32:
    case OK::IMM32_64:
      SetSInt(data, v, opcode.imm_pos, 32);
      return;
    case OK::IMM64:
      return SetSInt(data, v, opcode.imm_pos, 64);
      return;
    case OK::OFFPCREL8:
    case OK::OFFABS8:
      SetSInt(data, v, opcode.offset_pos, 8);
      return;
    case OK::OFFPCREL32:
    case OK::OFFABS32:
      SetSInt(data, v, opcode.offset_pos, 32);
      return;
  }
}

uint32_t Assemble(const Ins& ins, char* data) {
  ASSERT(!ins.has_reloc(), "reloc has not been resolved");
  const Opcode& opcode = *ins.opcode;
  uint8_t rex = opcode.rexw ? 8 : 0;
  // copy instruction data and patch it up but ignore rex prefix
  std::memcpy(data, opcode.data, opcode.num_bytes);
  for (int i = 0; i < opcode.num_fields; ++i) {
    SetOperand(opcode.fields[i], ins.operands[i], opcode, data, &rex);
  }
  if (rex != 0) {
    for (unsigned pos = 0; pos < opcode.num_bytes; ++pos) {
      uint8_t d = data[pos];
      // skip other prefixes
      if (d == 0xf0 || d == 0xf2 || d == 0xf3 || d == 0x66) continue;
      // std::memmove(data + pos + 1, data + pos, opcode.num_bytes - pos);
      for (unsigned end = opcode.num_bytes; end > pos; --end)
        data[end] = data[end - 1];
      data[pos] = rex | 0x40;
      return opcode.num_bytes + 1;
    }
  }
  return opcode.num_bytes;
}

bool UsesRex(const Ins& ins) {
  const Opcode& opcode = *ins.opcode;
  if (opcode.rexw) return true;
  for (int i = 0; i < opcode.num_fields; ++i) {
    const int64_t v = ins.operands[i];
    switch (opcode.fields[i]) {
      case OK::MODRM_RM_REG8:
      case OK::MODRM_REG8:
      case OK::BYTE_WITH_REG8:
        if (4 <= v && v <= 7) return true;
        // fallthrough
      case OK::MODRM_RM_REG16:
      case OK::MODRM_RM_REG32:
      case OK::MODRM_RM_REG64:
      case OK::MODRM_RM_XREG32:
      case OK::MODRM_RM_XREG64:
      case OK::MODRM_RM_XREG128:
      case OK::MODRM_RM_BASE:
      case OK::MODRM_REG16:
      case OK::MODRM_REG32:
      case OK::MODRM_REG64:
      case OK::MODRM_XREG32:
      case OK::MODRM_XREG64:
      case OK::MODRM_XREG128:
      case OK::SIB_BASE:
      case OK::SIB_INDEX:
      case OK::SIB_INDEX_AS_BASE:
      case OK::BYTE_WITH_REG16:
      case OK::BYTE_WITH_REG32:
      case OK::BYTE_WITH_REG64:
        if (v >> 3) return true;
        break;
      case OK::IMPLICIT_AL:
      case OK::IMPLICIT_AX:
      case OK::IMPLICIT_EAX:
      case OK::IMPLICIT_RAX:
      case OK::IMPLICIT_DX:
      case OK::IMPLICIT_EDX:
      case OK::IMPLICIT_RDX:
      case OK::IMPLICIT_CL:
      case OK::IMPLICIT_1:
      case OK::RIP_BASE:
      case OK::SIB_SCALE:
      case OK::IMM8:
      case OK::IMM8_16:
      case OK::IMM8_32:
      case OK::IMM8_64:
      case OK::IMM16:
      case OK::IMM32:
      case OK::IMM32_64:
      case OK::IMM64:
      case OK::OFFPCREL8:
      case OK::OFFABS8:
      case OK::OFFPCREL32:
      case OK::OFFABS32:
        break;
    }
  }
  return false;
}

const Opcode* FindOpcodeForMnemonic(std::string_view s) {
  uint32_t h = 5381;
  for (uint8_t c : s) {
    h = (h << 5U) + h + c;
  }
  h &= 0xffffU;

  for (uint32_t d = 0; d < MNEMONIC_HASH_TABLE_SIZE; ++d) {
    OPC opc = MnemonicHashTable[(h + d) % MNEMONIC_HASH_TABLE_SIZE];
    if (opc == OPC::invalid) return nullptr;
    if (OpcodeTableNames[uint32_t(opc)] == s)
      return &OpcodeTableEncodings[uint32_t(opc)];
  }
  return nullptr;
}

}  // namespace cwerg::x64
