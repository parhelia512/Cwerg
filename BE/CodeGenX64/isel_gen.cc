// NOTE: this file is PARTIALLY autogenerated via: ./isel_tab.py gen_c
// (c) Robert Muth - see LICENSE for more info

#include "BE/CodeGenX64/isel_gen.h"

#include <algorithm>
#include <cstdint>

#include "BE/Base/opcode_gen.h"
#include "BE/Base/serialize.h"
#include "BE/CpuX64//opcode_gen.h"

namespace cwerg::code_gen_x64 {
namespace {
using namespace cwerg;
using namespace cwerg::base;

// +-prefix converts an enum the underlying integer type
template <typename T>
constexpr auto operator+(T e) noexcept
    -> std::enable_if_t<std::is_enum<T>::value, std::underlying_type_t<T>> {
  return static_cast<std::underlying_type_t<T>>(e);
}
// Note: some of these checks may not be necesary if we can rely on
// DK to enforce ranges/
bool MatchSignedRange(int64_t hi, Const num) {
  if (DKFlavor(ConstKind(num)) == DK_FLAVOR_U) {
    const uint64_t val = ConstValueU(num);
    return val <= uint64_t(hi);
  } else {
    const int64_t val = ConstValueACS(num);
    return (-hi - 1) <= val && val <= hi;
  }
}

bool MatchUnsignedRange(uint64_t hi, Const num) {
  if (DKFlavor(ConstKind(num)) == DK_FLAVOR_U) {
    const uint64_t val = ConstValueU(num);
    return val <= hi;
  } else {
    const int64_t val = ConstValueACS(num);
    return 0 <= val && uint64_t(val) <= hi;
  }
}

bool MatchesOpCurb(C curb, Handle op) {
  switch (curb) {
    case C::INVALID:
      ASSERT(Kind(op) != RefKind::REG && Kind(op) != RefKind::CONST, "");
      return true;
    case C::REG:
      return Kind(op) == RefKind::REG &&
             Kind(RegCpuReg(Reg(op))) != RefKind::STACK_SLOT;
    case C::SP_REG:
      return Kind(op) == RefKind::REG &&
             Kind(RegCpuReg(Reg(op))) == RefKind::STACK_SLOT;
    case C::ANY:
    case C::ZERO:
      ASSERT(false, "NYI " << EnumToString(curb));
      return true;
    case C::REG_RAX:
      return Kind(op) == RefKind::REG &&
             CpuRegNo(CpuReg(RegCpuReg(Reg(op)))) == 0;
    case C::REG_RCX:
      return Kind(op) == RefKind::REG &&
             CpuRegNo(CpuReg(RegCpuReg(Reg(op)))) == 1;
    case C::REG_RDX:
      return Kind(op) == RefKind::REG &&
             CpuRegNo(CpuReg(RegCpuReg(Reg(op)))) == 2;
    case C::SIMM8:
      return Kind(op) == RefKind::CONST &&
             MatchSignedRange((1LL << 7) - 1, Const(op));
    case C::SIMM16:
      return Kind(op) == RefKind::CONST &&
             MatchSignedRange((1LL << 15) - 1, Const(op));
    case C::SIMM32:
      return Kind(op) == RefKind::CONST &&
             MatchSignedRange((1LL << 31) - 1, Const(op));
    case C::SIMM64:
      return Kind(op) == RefKind::CONST &&
             MatchSignedRange(0x7fff'ffff'ffff'ffff, Const(op));
    case C::UIMM8:
      return Kind(op) == RefKind::CONST &&
             MatchUnsignedRange((1ULL << 8) - 1, Const(op));
    case C::UIMM16:
      return Kind(op) == RefKind::CONST &&
             MatchUnsignedRange((1ULL << 16) - 1, Const(op));
    case C::UIMM32:
      return Kind(op) == RefKind::CONST &&
             MatchUnsignedRange((1ULL << 32) - 1, Const(op));
    case C::UIMM64:
      return Kind(op) == RefKind::CONST &&
             MatchUnsignedRange(0xffff'ffff'ffff'ffff, Const(op));
  }
  ASSERT(false, "unexpected C " << EnumToString(curb));
  return false;
}

uint64_t ExtractTypeMaskForPattern(Ins ins) {
  uint64_t reg_matcher = 0;
  unsigned num_ops = InsOpcode(ins).num_operands;
  for (unsigned i = 0; i < num_ops; ++i) {
    const Handle h = InsOperand(ins, i);
    if (Kind(h) == RefKind::REG) {
      reg_matcher |= uint64_t(RegKind(Reg(h))) << 8 * i;
    } else if (Kind(h) == RefKind::CONST) {
      reg_matcher |= uint64_t(ConstKind(Const(h))) << 8 * i;
    }
  }
  return reg_matcher;
}

bool PatternMatchesTypeCurbs(const Pattern& pat, uint64_t type_mask) {
  return type_mask == pat.type_curbs_as_int;
}

bool PatternMatchesOpCurbs(const Pattern& pat, Ins ins) {
  unsigned num_ops = InsOpcode(ins).num_operands;
  for (unsigned i = 0; i < num_ops; ++i) {
    if (!MatchesOpCurb(pat.op_curbs[i], InsOperand(ins, i))) return false;
  }
  return true;
}

}  // namespace

/* @AUTOGEN-START@ */

enum F {
  NO_INDEX = 4,
  NO_BASE = 4,
  RIP = 0,
  SCALE1 = 0,
  SCALE2 = 1,
  SCALE4 = 2,
  SCALE8 = 3,
  RAX = 0,
  RCX = 1,
  RDX = 2,
  RBX = 3,
  RSP = 4,
  RBP = 5,
  RSI = 6,
  RDI = 7,
  R8 = 8,
  R9 = 9,
  R10 = 10,
  R11 = 11,
  R12 = 12,
  R13 = 13,
  R14 = 14,
  R15 = 15,
  XMM0 = 0,
  XMM1 = 1,
  XMM2 = 2,
  XMM3 = 3,
  XMM4 = 4,
  XMM5 = 5,
  XMM6 = 6,
  XMM7 = 7,
  XMM8 = 8,
  XMM9 = 9,
  XMM10 = 10,
  XMM11 = 11,
  XMM12 = 12,
  XMM13 = 13,
  XMM14 = 14,
  XMM15 = 15,
};

const char* const C_ToStringMap[] = {
    "INVALID",  // 0
    "ZERO",     // 1
    "ANY",      // 2
    "REG",      // 3
    "SP_REG",   // 4
    "SIMM8",    // 5
    "SIMM16",   // 6
    "SIMM32",   // 7
    "SIMM64",   // 8
    "UIMM8",    // 9
    "UIMM16",   // 10
    "UIMM32",   // 11
    "UIMM64",   // 12
    "REG_RAX",  // 13
    "REG_RCX",  // 14
    "REG_RDX",  // 15
    "ZZZ",      // 16
};
const char* EnumToString(C x) { return C_ToStringMap[unsigned(x)]; }

const char* const P_ToStringMap[] = {
    "invalid",         // 0
    "reg01",           // 1
    "reg0",            // 2
    "reg1",            // 3
    "reg2",            // 4
    "reg3",            // 5
    "reg4",            // 6
    "tmp_gpr",         // 7
    "tmp_flt",         // 8
    "scratch_gpr",     // 9
    "num0",            // 10
    "num1",            // 11
    "num2",            // 12
    "num3",            // 13
    "num4",            // 14
    "spill01",         // 15
    "spill0",          // 16
    "spill1",          // 17
    "spill2",          // 18
    "stk1_offset2",    // 19
    "stk0_offset1",    // 20
    "stk1",            // 21
    "bbl0",            // 22
    "bbl1",            // 23
    "bbl2",            // 24
    "fun0",            // 25
    "mem0_num1_prel",  // 26
    "mem1_num2_prel",  // 27
    "fun1_prel",       // 28
    "jtb1_prel",       // 29
    "frame_size",      // 30
    "ZZZ",             // 31
};
const char* EnumToString(P x) { return P_ToStringMap[unsigned(x)]; }

/* @AUTOGEN-END@ */

namespace {
#include "BE/CodeGenX64/isel_gen_patterns.h"
}  // namespace

const Pattern* FindMatchingPattern(Ins ins) {
  const uint64_t type_matcher = ExtractTypeMaskForPattern(ins);
  const OPC opc = InsOPC(ins);
  const uint16_t end = kPatternJumper[unsigned(opc) + 1];
  for (unsigned p = kPatternJumper[unsigned(opc)]; p < end; ++p) {
    const Pattern& pat = kPatterns[p];
    if (PatternMatchesTypeCurbs(pat, type_matcher) &&
        PatternMatchesOpCurbs(pat, ins)) {
      return &pat;
    }
  }

  return nullptr;
}

int64_t ExtractReg(Reg reg) {
  ASSERT(Kind(reg) == RefKind::REG, "not a reg " << EnumToString(Kind(reg)));
  CpuReg cpu_reg(RegCpuReg(reg));
  ASSERT(Kind(cpu_reg) == RefKind::CPU_REG, "");
  return CpuRegNo(cpu_reg);
}

int64_t ExtractSpilledReg(Reg reg) {
  ASSERT(Kind(reg) == RefKind::REG, "not a reg " << EnumToString(Kind(reg)));
  StackSlot slot(RegCpuReg(reg));
  ASSERT(Kind(slot) == RefKind::STACK_SLOT, "");
  return StackSlotOffset(slot);
}

// TODO: should this return an uint32_t
int32_t GetStackOffset(Handle stk, Handle num) {
  ASSERT(Kind(stk) == RefKind::STK, "");
  ASSERT(Kind(num) == RefKind::CONST, "");
  return StkSlot(Stk(stk)) + ConstValueInt32(Const(num));
}

int64_t GetStackOffset(Stk stk, Const offset) {
  ASSERT(Kind(stk) == RefKind::STK && Kind(offset) == RefKind::CONST, "");
  return StkSlot(stk) + ConstValueInt64(offset);
}

int64_t ExtractTmplArgOP(Ins ins, P arg, const EmitContext& ctx) {
  switch (arg) {
    case P::invalid:
      break;
    case P::reg01:
      ASSERT(InsOperand(ins, 0) == InsOperand(ins, 1), "");
      return ExtractReg(Reg(InsOperand(ins, 0)));
    case P::reg0:
    case P::reg1:
    case P::reg2:
    case P::reg3:
    case P::reg4:
      return ExtractReg(Reg(InsOperand(ins, +arg - +P::reg0)));
    case P::tmp_gpr:
      return +F::RAX;
    case P::tmp_flt:
      return +F::XMM0;
    case P::scratch_gpr: {
      CpuReg cpu_reg = ctx.scratch_cpu_reg;
      ASSERT(Kind(cpu_reg) == RefKind::CPU_REG &&
                 CpuRegKind(cpu_reg) == +CPU_REG_KIND::GPR,
             "");
      return CpuRegNo(cpu_reg);
    }
    case P::num0:
    case P::num1:
    case P::num2:
    case P::num3:
    case P::num4: {
      Const num = Const(InsOperand(ins, +arg - +P::num0));
      return ConstValueInt64(num);
    }
    case P::spill01:
      ASSERT(InsOperand(ins, 0) == InsOperand(ins, 1), "");
    case P::spill0:
    case P::spill1:
    case P::spill2: {
      unsigned no = arg == P::spill01 ? 0 : +arg - +P::spill0;
      const Reg reg = Reg(InsOperand(ins, no));
      ASSERT(Kind(reg) == RefKind::REG, "");
      const StackSlot slot(RegCpuReg(reg));
      ASSERT(Kind(slot) == RefKind::STACK_SLOT, "");
      return StackSlotOffset(slot);
    }
    case P::stk1_offset2:
      return GetStackOffset(InsOperand(ins, 1), InsOperand(ins, 2));
    case P::stk0_offset1:
      return GetStackOffset(InsOperand(ins, 0), InsOperand(ins, 1));
    case P::stk1:
      return GetStackOffset(InsOperand(ins, 1), ConstNewOffset(0));
    case P::frame_size:
      return ctx.FrameSize();
    case P::bbl0:
    case P::bbl1:
    case P::bbl2:
    case P::fun0:
    case P::mem0_num1_prel:
    case P::mem1_num2_prel:
    case P::fun1_prel:
    case P::jtb1_prel:
      // relocs
      return 0;
  }
  ASSERT(false, "unsupported parmm " << +arg << " " << EnumToString(arg));
  return 0;
}

void MaybeHandleReloc(x64::Ins* cpuins, unsigned pos, Ins ins, P op) {
  ASSERT(!cpuins->has_reloc(), "");
  switch (op) {
    case P::bbl0:
    case P::bbl1:
    case P::bbl2: {
      const Bbl bbl = Bbl(InsOperand(ins, +op - +P::bbl0));
      cpuins->set_reloc(elf::RELOC_TYPE_X86_64::PC32, true, pos,
                        StrData(Name(bbl)));
      return;
    }
    case P::fun0: {
      const Fun fun = Fun(InsOperand(ins, 0));
      cpuins->set_reloc(elf::RELOC_TYPE_X86_64::PC32, false, pos,
                        StrData(Name(fun)));
      return;
    }
    case P::fun1_prel: {
      const Fun fun = Fun(InsOperand(ins, 1));
      ASSERT(FunKind(fun) != FUN_KIND::EXTERN, "undefined Fun" << Name(fun));
      cpuins->set_reloc(elf::RELOC_TYPE_X86_64::PC32, false, pos,
                        StrData(Name(fun)));
      return;
    }
    case P::mem1_num2_prel:
    case P::mem0_num1_prel: {
      const Mem mem = Mem(InsOperand(ins, +op - +P::mem0_num1_prel));
      ASSERT(MemKind(mem) != MEM_KIND::EXTERN, "undefined Fun" << Name(mem));
      const Const num = Const(InsOperand(ins, +op - +P::mem0_num1_prel + 1));
      cpuins->set_reloc(elf::RELOC_TYPE_X86_64::PC32, false, pos,
                        StrData(Name(mem)));
      cpuins->operands[pos] = ConstValueInt64(num);
      return;
    }
    case P::jtb1_prel: {
      const Jtb jtb = Jtb(InsOperand(ins, 1));
      cpuins->set_reloc(elf::RELOC_TYPE_X86_64::PC32, true, pos,
                        StrData(Name(jtb)));
      return;
    }
    default:
      return;
  }
}

x64::Ins MakeIns(x64::OPC opc_enum, int64_t x0, int64_t x1, int64_t x2,
                 int64_t x3, int64_t x4, int64_t x5) {
  const x64::Opcode* opc = &x64::OpcodeTableEncodings[+opc_enum];
  return x64::Ins{opc, {x0, x1, x2, x3, x4, x5}};
}

x64::Ins MakeInsFromTmpl(const InsTmpl& tmpl, Ins ins, const EmitContext& ctx) {
  x64::Ins out;
  out.opcode = &x64::OpcodeTableEncodings[unsigned(tmpl.opcode)];
  // InsRenderToAsm(ins, &std::cout);
  // std::cout << "\n" <<  OpcodeName(out.opcode) << "\n";
  for (unsigned o = 0; o < out.opcode->num_fields; ++o) {
    if ((tmpl.template_mask & (1U << o)) == 0) {
      // fixed operand - we uses these verbatim
      out.operands[o] = tmpl.operands[o];
    } else {
      // parameters require extra processing
      const P param = P(tmpl.operands[o]);
      // std::cout << "@@Handle " << o << " field "
      //          << x64::EnumToString(out.opcode->fields[o])
      //          <<  " param " << EnumToString(param) << "\n";
      out.operands[o] = ExtractTmplArgOP(ins, param, ctx);
      // Note: this may overwrite    out.operands[o]
      MaybeHandleReloc(&out, o, ins, param);
    }
  }
  return out;
}

void FunAddNop1ForCodeSel(Fun fun, std::vector<Ins>* inss) {
  for (Bbl bbl : FunBblIter(fun)) {
    inss->clear();
    bool dirty = false;
    Reg tmp;
    for (Ins ins : BblInsIter(bbl)) {
      switch (InsOPC(ins)) {
        case OPC::SWITCH:
          tmp = FunGetScratchReg(fun, DK::C64, "nop1", false);
          inss->push_back(InsNew(OPC::NOP1, tmp));
          inss->push_back(ins);
          dirty = true;
          break;
        case OPC::ST:
          tmp = FunGetScratchReg(fun, DK::S64, "nop1", false);
          inss->push_back(InsNew(OPC::NOP1, tmp));
          inss->push_back(ins);
          dirty = true;
          break;
        default:
          inss->push_back(ins);
          break;
      }
    }
    if (dirty) BblReplaceInss(bbl, *inss);
  }
}

void EmitFunProlog(const EmitContext& ctx, std::vector<x64::Ins>* output) {
  for (int i = GPR_REGS.size() - 1; i >= 0; --i) {
    if (ctx.gpr_reg_mask & (1U << i)) {
      output->push_back(MakeIns(x64::OPC::push_64_r, i));
    }
  }
  const uint32_t stk_adjust = ctx.StackAdjustment();
  if (stk_adjust > 0) {
    output->push_back(MakeIns(x64::OPC::sub_64_mr_imm32, +F::RSP, stk_adjust));
  }

  uint32_t offset = ctx.stk_size;
  for (int i = FLT_REGS.size() - 1; i >= 0; --i) {
    if (ctx.flt_reg_mask & (1U << i)) {
      output->push_back(MakeIns(x64::OPC::movsd_mbis32_x, +F::RSP, +F::NO_INDEX,
                                +F::SCALE1, offset, i));
      offset += 8;
    }
  }
}

void EmitFunEpilog(const EmitContext& ctx, std::vector<x64::Ins>* output) {
  const size_t start = output->size();
  // we will revert everything at the end
  output->push_back(MakeIns(x64::OPC::ret));
  for (int i = GPR_REGS.size() - 1; i >= 0; --i) {
    if (ctx.gpr_reg_mask & (1U << i)) {
      output->push_back(MakeIns(x64::OPC::pop_64_r, i));
    }
  }
  const uint32_t stk_adjust = ctx.StackAdjustment();
  if (stk_adjust > 0) {
    output->push_back(MakeIns(x64::OPC::add_64_mr_imm32, +F::RSP, stk_adjust));
  }

  uint32_t offset = ctx.stk_size;
  for (int i = FLT_REGS.size() - 1; i >= 0; --i) {
    if (ctx.flt_reg_mask & (1U << i)) {
      output->push_back(MakeIns(x64::OPC::movsd_x_mbis32, i, +F::RSP,
                                +F::NO_INDEX, +F::SCALE1, offset));
      offset += 8;
    }
  }

  std::reverse(output->begin() + start, output->end());
}

}  // namespace cwerg::code_gen_x64
